using System;
using System.IO;
using System.Linq;
using FastString.Unicode;

namespace FastString.DataGen
{
	class MainClass
	{
		static readonly char[] separator = { ';' };
		static readonly utf8 CharInfoFormat = new utf8(@"			new CharInfo
			{{
				Codepoint = 0x{0},
				Category = UnicodeCategory.{1},
				Mirrored = {2}");
		static readonly utf8 IsMirrored = new utf8("Y");
		static readonly utf8 EndNameBytes = new utf8("})  /* {0} */");
		static readonly utf8 EndInstance = new utf8(@"
			},
");

		public static void Main(string[] args)
		{
			// Data file available at ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
			var data = new utf8(File.ReadAllBytes(args[0]));

			var lines = new Splitter('\n', data);

			var mainOutFile = new FileStream("CharInfo.RawData.cs", FileMode.Create, FileAccess.Write);
			var main = new Utf8Writer(mainOutFile);
			main.Append(@"
// This file is autogenerated by a tool.
// Please do not edit it.
using System.Collections.Generic;

namespace FastString.Unicode
{
	public partial struct CharInfo
	{
		public static IReadOnlyList<CharInfo> Characters = new CharInfo[]
		{
");
			int i = 0;
			foreach (var line in lines)
			{
				i++;
				Console.WriteLine(i);
				if (line.IsEmpty) continue;
				var parts = line.Split(separator);
				// Schema given in ftp://ftp.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.html
				main.AppendFormat(CharInfoFormat, parts[0], CharInfo.ParseCategory(parts[2]), (parts[9] == IsMirrored ? "true" : "false"));
				if (parts[1].HasValue)
				{
					// Everything should have a name...
					main.Append(@",
				Name = new utf8(new byte[]{");
					foreach (var b in parts[1].Bytes)
					{
						main.Append(b);
						main.Append(',');
					}
					main.AppendFormat(EndNameBytes, parts[1]);
				}

				// Simple cases.
				if (parts[12].HasValue)
				{
					main.Append(@",
				Uppercase = 0x");
					main.Append(parts[12]);
				}
				if (parts[13].HasValue)
				{
					main.Append(@",
				Lowercase = 0x");
					main.Append(parts[13]);
				}
				if (parts[14].HasValue)
				{
					main.Append(@",
				Titlecase = 0x");
					main.Append(parts[14]);
				}

				// Numeric value.
				// There are several different numeric values listed.
				if (parts[6].HasValue)
				{
					main.Append(@",
				NumericValue = ");
					main.Append(parts[6]);
				}
				else if (parts[7].HasValue)
				{
					main.Append(@",
				NumericValue = ");
					main.Append(parts[7]);
				}
				else if (parts[8].HasValue)
				{
					main.Append(@",
				NumericValue = ");
					// Parse the subsequent rational number.
					var p = parts[8].Split(new char[] { '/' }, 3);
					if (p.Length == 1)
					{
						main.Append(parts[8]);
					}
					else if (p.Length == 2)
					{
						Console.WriteLine("fraction! [{0}] slash [{1}]", p[0], p[1]);
						Console.WriteLine("fraction! [{0}] slash [{1}]", p[0].Trim(), p[1].Trim());
						main.Append(utf8.ParseInt(p[0].Trim()) * 1.0 / utf8.ParseInt(p[1].Trim()));
					}
					else
					{
						Console.WriteLine("error on line {0}: can't parse rational number {1}", i, parts[8]);
					}
				}

				main.Append(EndInstance);
			}
			main.Append(@"
		};
	}
}
");
			mainOutFile.Flush();
			mainOutFile.Close();
		}
	}
}
